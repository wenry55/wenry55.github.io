I"×<h1 id="apply">apply</h1>
<h5 id="invoke-a-function-as-a-method-of-an-object">invoke a function as a method of an object</h5>

<blockquote>
  <p>ì´ í•¨ìˆ˜ëŠ” í•¨ìˆ˜í˜• ì˜¤ë¸Œì íŠ¸ë¥¼ íŒŒë¼ë©”í„°ë¡œ ì£¼ì–´ì§„ ì˜¤ë¸Œì íŠ¸ì˜ ë©”ì„œë“œë¡œ ì ìš©í•œë‹¤ëŠ” ëœ»ìœ¼ë¡œ ì´í•´í•˜ë©´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤.
ë§Œì•½ ì£¼ì–´ì§„ ì˜¤ë¸Œì íŠ¸ê°€ null ì¼ ê²½ìš°, thisëŠ” global objectë¥¼ ì§€ì¹­í•˜ê²Œ ë©ë‹ˆë‹¤.</p>
</blockquote>

<blockquote>
  <p>í•œí¸ìœ¼ë¡œ ë‹¤ë¥´ê²Œ ìƒê°í•´ ë³´ë©´, ì˜¤ë¸Œì íŠ¸ì™€ ë©”ì„œë“œê°€ ë¶„ë¦¬ë˜ì–´ ìˆëŠ” í˜•íƒœë¼ê³ ë„ ìƒê°í•´ ë³¼ ìˆ˜ ìˆì„ê²ƒ ê°™ìŠµë‹ˆë‹¤.</p>
</blockquote>

<h4 id="synopsis">Synopsis</h4>

<p>function.apply(thisobj, args)</p>

<h4 id="arguments">Arguments</h4>
<p><code class="highlighter-rouge">thisobj</code></p>

<p>The object to which function is to be applied. In the body of the function, thisobj becomes the value of the <code class="highlighter-rouge">this</code> keyword. If this argument is <code class="highlighter-rouge">null</code>, the global object is used.</p>

<p>The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).</p>

<blockquote>
  <p>Note: While the syntax of this function is almost identical to that of &gt; call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.</p>
</blockquote>

<blockquote>
  <p>Note: When the first argument is undefined or null a similar outcome can &gt; be achieved using the array spread syntax.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">fullName</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Mary</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">lastName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Doe</span><span class="dl">"</span>
<span class="p">}</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">fullName</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">person1</span><span class="p">);</span>  <span class="c1">// Will return "Mary Doe"</span>
</code></pre></div></div>

<p>ë¨¼ì € apply í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ë©´,
ì´ í•¨ìˆ˜ëŠ” í•œ ì˜¤ë¸Œì íŠ¸ì—ì„œ ì •ì˜í•œ í•¨ìˆ˜í˜• ì˜¤ë¸Œì íŠ¸ë¥¼ ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.
ì²«ë²ˆì¬ íŒŒë¼ë©”í„°ëŠ” ì´ í•¨ìˆ˜ë¥¼ ì ìš©í•  ì˜¤ë¸Œì íŠ¸ì´ê³ , ë‹¤ìŒ íŒŒë¼ë©”í„°ë“¤ì€ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©ë˜ëŠ” íŒŒë¼ë©”í„° ì–´ë ˆì´ë¥¼ ì§€ì •í•œë‹¤.</p>

<ul>
  <li>Array(5) gives you an array with length 5 but no values, hence you canâ€™t iterate over it.</li>
  <li>Array.apply(null, Array(5)).map(function () {}) gives you an array with length 5 and undefined as values, now it can be iterated over.</li>
  <li>Array.apply(null, Array(5)).map(function (x, i) { return i; }) gives you an array with length 5 and values 0,1,2,3,4.</li>
  <li>Array(5).forEach(alert) does nothing, Array.apply(null, Array(5)).forEach(alert) gives you 5 alerts</li>
  <li>ES6 gives us Array.from so now you can also use Array.from(Array(5)).forEach(alert)</li>
  <li>If you want to initialize with a certain value, these are good to knowsâ€¦
Array.from(â€˜abcdeâ€™), Array.from(â€˜xâ€™.repeat(5))
or Array.from({length: 5}, (v, i) =&gt; i)   // gives [0, 1, 2, 3, 4]</li>
</ul>

<p><a href="https://stackoverflow.com/questions/28416547/difference-between-array-applynull-arrayx-and-arrayx">Difference between Array.apply(null, Array(x)) and Array(x)</a></p>

<p>There is a difference, a quite significant one.</p>

<p>The Array constructor either accepts one single number, giving the lenght of the array, and an array with â€œemptyâ€ indices is created, or more correctly the length is set but the array doesnâ€™t really contain anything</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// creates [], with a length of 3</span>
</code></pre></div></div>

<p>When calling the array constructor with a number as the only argument, you create an array that is empty, and that canâ€™t be iterated with the usual Array methods.</p>

<p>Orâ€¦ the Array constructor accepts several arguments, whereas an array is created where each argument is a value in the array</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// creates an array [1,2,3] etc.</span>
</code></pre></div></div>

<p>When you call this</p>

<p>Array.apply(null, Array(3) )
It getâ€™s a little more interesting.</p>

<p>apply accepts the this value as the first argument, and as itâ€™s not useful here, itâ€™s set to null</p>

<p>The interesting part is the second argument, where an empty array is being passed in.
As apply accepts an array it would be like calling</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">);</span> <span class="c1">// ì—¬ê¸°ì„œ ìºìŠ¤íŒ…ì´ ì¼ì–´ë‚˜ë²„ë¦½ë‹ˆë‹¤!</span>
</code></pre></div></div>
<p>and that creates an array with three indices thatâ€™s not empty, but have the value actually set to undefined, which is why it can be iterated over.</p>

<p>TL;DR
The main difference is that Array(3) creates an array with three indices that are empty. In fact, they donâ€™t really exist, the array just have a length of 3.</p>

<p>Passing in such an array with empty indices to the Array constructor using apply is the same as doing Array(undefined, undefined, undefined);, which creates an array with three undefined indices, and undefined is in fact a value, so itâ€™s not empty like in the first example.</p>

<p>Array methods like map() can only iterate over actual values, not empty indices.</p>
:ET